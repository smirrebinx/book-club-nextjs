# Claude Development Guidelines

This document outlines best practices for developing with React, TypeScript, Next.js, Tailwind CSS, and CSS Variables while maintaining WCAG AA accessibility standards.

## Table of Contents

1. [React Best Practices](#react-best-practices)
2. [TypeScript Guidelines](#typescript-guidelines)
3. [Next.js Patterns](#nextjs-patterns)
4. [Tailwind CSS & CSS Variables](#tailwind-css--css-variables)
5. [WCAG Accessibility Standards](#wcag-accessibility-standards)
6. [Component Architecture](#component-architecture)
7. [Performance Optimization](#performance-optimization)

---

## React Best Practices

### Component Structure

```typescript
// Good: Functional component with clear props interface
interface ButtonProps {
  children: React.ReactNode;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

export function Button({ children, onClick, variant = 'primary', disabled = false }: ButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`btn btn--${variant}`}
      aria-disabled={disabled}
    >
      {children}
    </button>
  );
}
```

### Hooks Guidelines

- **Keep hooks at the top level** - Never call hooks inside loops, conditions, or nested functions
- **Custom hooks naming** - Always prefix with `use` (e.g., `useBookClub`, `useVoting`)
- **Dependency arrays** - Be explicit about all dependencies in useEffect, useMemo, and useCallback

```typescript
// Good: Clear dependencies
useEffect(() => {
  fetchBooks(userId);
}, [userId]); // userId explicitly listed

// Bad: Missing dependencies
useEffect(() => {
  fetchBooks(userId);
}, []); // userId should be listed
```

### State Management

```typescript
// Good: Derived state instead of duplicating
function BookList({ books }) {
  const publishedBooks = books.filter(book => book.isPublished);
  // Don't create separate state for filtered data
}

// Good: Single source of truth
const [formData, setFormData] = useState({
  title: '',
  author: '',
  isbn: ''
});

// Bad: Multiple related states
const [title, setTitle] = useState('');
const [author, setAuthor] = useState('');
const [isbn, setIsbn] = useState('');
```

### Event Handlers

```typescript
// Good: Descriptive names with 'handle' prefix
const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  // logic here
};

const handleVoteClick = (bookId: string) => {
  // logic here
};
```

---

## TypeScript Guidelines

### Type Safety

```typescript
// Good: Explicit types for function parameters and returns
function calculateVotes(votes: number[]): number {
  return votes.reduce((sum, vote) => sum + vote, 0);
}

// Good: Interface for objects
interface Book {
  id: string;
  title: string;
  author: string;
  votes: number;
  suggestedBy: string;
  createdAt: Date;
}

// Good: Type for API responses
type ApiResponse<T> = {
  data: T;
  error?: string;
  status: number;
};
```

### Avoid `any`

```typescript
// Bad
function processData(data: any) {
  return data.value;
}

// Good: Use specific types
function processData(data: { value: string }) {
  return data.value;
}

// Good: Use generics when needed
function processData<T extends { value: string }>(data: T) {
  return data.value;
}
```

### Type Utilities

```typescript
// Use built-in utility types
type PartialBook = Partial<Book>; // All properties optional
type ReadonlyBook = Readonly<Book>; // All properties readonly
type BookTitleOnly = Pick<Book, 'title' | 'author'>; // Pick specific properties
type BookWithoutId = Omit<Book, 'id'>; // Omit specific properties
```

### Enums vs Union Types

```typescript
// Good: Use union types for simple cases
type VoteStatus = 'pending' | 'approved' | 'rejected';

// Good: Use enums for more complex cases
enum BookStatus {
  Suggested = 'SUGGESTED',
  InVoting = 'IN_VOTING',
  Selected = 'SELECTED',
  Read = 'READ',
  Archived = 'ARCHIVED'
}
```

---

## Next.js Patterns

### File Structure

```
app/
├── (auth)/
│   ├── login/
│   │   └── page.tsx
│   └── layout.tsx
├── (dashboard)/
│   ├── books/
│   │   ├── [id]/
│   │   │   └── page.tsx
│   │   └── page.tsx
│   ├── meetings/
│   │   └── page.tsx
│   └── layout.tsx
├── api/
│   ├── books/
│   │   └── route.ts
│   └── votes/
│       └── route.ts
├── globals.css
└── layout.tsx
```

### Server Components (Default)

```typescript
// app/books/page.tsx
// Good: Server component for data fetching
async function BooksPage() {
  const books = await fetchBooks(); // Server-side data fetch
  
  return (
    <div>
      <h1>Books</h1>
      <BookList books={books} />
    </div>
  );
}
```

### Client Components

```typescript
// components/VoteButton.tsx
'use client';

// Good: Use client components only when needed
// - Event handlers (onClick, onChange, etc.)
// - Hooks (useState, useEffect, etc.)
// - Browser APIs
import { useState } from 'react';

export function VoteButton({ bookId }: { bookId: string }) {
  const [votes, setVotes] = useState(0);
  
  const handleVote = () => {
    setVotes(prev => prev + 1);
  };
  
  return (
    <button onClick={handleVote}>
      Vote ({votes})
    </button>
  );
}
```

### API Routes

```typescript
// app/api/books/route.ts
import { NextRequest, NextResponse } from 'next/server';

// Good: Type-safe API routes
export async function GET(request: NextRequest) {
  try {
    const books = await getBooks();
    return NextResponse.json({ data: books }, { status: 200 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch books' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const newBook = await createBook(body);
    return NextResponse.json({ data: newBook }, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create book' },
      { status: 500 }
    );
  }
}
```

### Loading States

```typescript
// app/books/loading.tsx
// Good: Provide loading UI
export default function Loading() {
  return (
    <div className="loading-container">
      <div className="spinner" aria-label="Loading books" />
    </div>
  );
}
```

### Error Handling

```typescript
// app/books/error.tsx
'use client';

// Good: Error boundary
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div role="alert">
      <h2>Something went wrong!</h2>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

### Metadata

```typescript
// app/books/[id]/page.tsx
import { Metadata } from 'next';

// Good: Dynamic metadata
export async function generateMetadata({ params }: { params: { id: string } }): Promise<Metadata> {
  const book = await getBook(params.id);
  
  return {
    title: `${book.title} - Book Club`,
    description: `Details about ${book.title} by ${book.author}`,
  };
}
```

---

## Tailwind CSS & CSS Variables

### Using CSS Variables from globals.css

```css
/* globals.css */
:root {
  /* Colors */
  --color-primary: #3b82f6;
  --color-primary-hover: #2563eb;
  --color-secondary: #8b5cf6;
  --color-background: #ffffff;
  --color-text: #1f2937;
  --color-border: #e5e7eb;
  
  /* Spacing */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  
  /* Typography */
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
  --font-size-2xl: 1.5rem;
  
  /* Borders */
  --border-radius-sm: 0.25rem;
  --border-radius-md: 0.375rem;
  --border-radius-lg: 0.5rem;
}

.dark {
  --color-background: #1f2937;
  --color-text: #f9fafb;
  --color-border: #374151;
}
```

### Tailwind Configuration

```typescript
// tailwind.config.ts
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: 'var(--color-primary)',
        'primary-hover': 'var(--color-primary-hover)',
        secondary: 'var(--color-secondary)',
        background: 'var(--color-background)',
        text: 'var(--color-text)',
        border: 'var(--color-border)',
      },
      spacing: {
        xs: 'var(--spacing-xs)',
        sm: 'var(--spacing-sm)',
        md: 'var(--spacing-md)',
        lg: 'var(--spacing-lg)',
        xl: 'var(--spacing-xl)',
      },
      fontSize: {
        sm: 'var(--font-size-sm)',
        base: 'var(--font-size-base)',
        lg: 'var(--font-size-lg)',
        xl: 'var(--font-size-xl)',
        '2xl': 'var(--font-size-2xl)',
      },
      borderRadius: {
        sm: 'var(--border-radius-sm)',
        md: 'var(--border-radius-md)',
        lg: 'var(--border-radius-lg)',
      },
    },
  },
  plugins: [],
};

export default config;
```

### Using Tailwind with CSS Variables

```typescript
// Good: Combine Tailwind utilities with CSS variables
<button className="bg-primary hover:bg-primary-hover text-white px-md py-sm rounded-md">
  Click me
</button>

// Good: Use arbitrary values for one-off cases
<div className="w-[var(--custom-width)]" style={{ '--custom-width': '300px' } as React.CSSProperties}>
  Content
</div>

// Good: Responsive design with Tailwind
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-md">
  {items.map(item => <Card key={item.id} {...item} />)}
</div>
```

### Class Organization

```typescript
// Good: Organize classes logically
<button className={`
  // Layout
  flex items-center justify-center
  // Spacing
  px-md py-sm
  // Typography
  text-base font-medium
  // Colors
  bg-primary text-white
  // Borders
  rounded-md border-2 border-transparent
  // States
  hover:bg-primary-hover
  focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2
  disabled:opacity-50 disabled:cursor-not-allowed
  // Transitions
  transition-colors duration-200
`}>
  Submit
</button>
```

---


## WCAG Accessibility Standards

Follow WCAG 2.1 Level AA compliance standards.

---
## Component Architecture

### Component Types

```typescript
// 1. Presentational Components (UI only)
interface CardProps {
  title: string;
  description: string;
  imageUrl?: string;
}

export function Card({ title, description, imageUrl }: CardProps) {
  return (
    <div className="card">
      {imageUrl && <img src={imageUrl} alt="" />}
      <h3>{title}</h3>
      <p>{description}</p>
    </div>
  );
}

// 2. Container Components (logic + data)
export function BookListContainer() {
  const [books, setBooks] = useState<Book[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchBooks().then(setBooks).finally(() => setLoading(false));
  }, []);
  
  if (loading) return <LoadingSpinner />;
  
  return <BookList books={books} />;
}

// 3. Layout Components
export function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen flex">
      <Sidebar />
      <main className="flex-1 p-lg">
        {children}
      </main>
    </div>
  );
}
```

### Composition Pattern

```typescript
// Good: Composable components
<Card>
  <Card.Header>
    <Card.Title>Book Title</Card.Title>
  </Card.Header>
  <Card.Body>
    <Card.Description>Description here</Card.Description>
  </Card.Body>
  <Card.Footer>
    <Button>Read More</Button>
  </Card.Footer>
</Card>

// Implementation
export function Card({ children }: { children: React.ReactNode }) {
  return <div className="card">{children}</div>;
}

Card.Header = function CardHeader({ children }: { children: React.ReactNode }) {
  return <div className="card-header">{children}</div>;
};

Card.Title = function CardTitle({ children }: { children: React.ReactNode }) {
  return <h3 className="card-title">{children}</h3>;
};

// ... etc
```

---

## Performance Optimization

### Code Splitting

```typescript
// Good: Dynamic imports for large components
import dynamic from 'next/dynamic';

const BookEditor = dynamic(() => import('@/components/BookEditor'), {
  loading: () => <p>Loading editor...</p>,
  ssr: false, // Disable SSR if needed
});
```

### Memoization

```typescript
// Good: Memoize expensive calculations
const sortedBooks = useMemo(() => {
  return books.sort((a, b) => b.votes - a.votes);
}, [books]);

// Good: Memoize callback functions passed to children
const handleVote = useCallback((bookId: string) => {
  setVotes(prev => ({ ...prev, [bookId]: (prev[bookId] || 0) + 1 }));
}, []);

// Good: Memoize components when appropriate
const BookCard = memo(function BookCard({ book }: { book: Book }) {
  return (
    <div className="book-card">
      <h3>{book.title}</h3>
      <p>{book.author}</p>
    </div>
  );
});
```

### Image Optimization

```typescript
// Good: Use Next.js Image component
import Image from 'next/image';

<Image
  src="/book-cover.jpg"
  alt="Book cover"
  width={300}
  height={400}
  priority // For above-the-fold images
  placeholder="blur"
  blurDataURL="/book-cover-blur.jpg"
/>
```

### Database Queries

```typescript
// Good: Efficient queries
// Only fetch needed fields
const books = await db.books.find({}, {
  projection: { title: 1, author: 1, votes: 1 }
});

// Use indexes for frequently queried fields
// In MongoDB schema
bookSchema.index({ suggestedBy: 1, createdAt: -1 });
```

---

## Testing Considerations

### Accessibility Testing

```typescript
// Use tools like:
// - jest-axe for automated testing
// - WAVE browser extension
// - Screen reader testing (NVDA, JAWS, VoiceOver)

import { axe, toHaveNoViolations } from 'jest-axe';
expect.extend(toHaveNoViolations);

test('Button has no accessibility violations', async () => {
  const { container } = render(<Button>Click me</Button>);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

---

## Quick Reference Checklist

### Before Committing Code

- [ ] TypeScript has no errors (`tsc --noEmit`)
- [ ] All interactive elements are keyboard accessible
- [ ] Color contrast meets WCAG AA standards (4.5:1 for text)
- [ ] Images have appropriate alt text
- [ ] Forms have associated labels
- [ ] Focus indicators are visible
- [ ] ARIA attributes are used correctly (when needed)
- [ ] Semantic HTML is used
- [ ] No console errors or warnings
- [ ] Components are properly typed
- [ ] CSS variables are used consistently
- [ ] Responsive design works on mobile/tablet/desktop

### Accessibility Quick Wins

1. Use semantic HTML (`<button>`, `<nav>`, `<main>`, etc.)
2. Always include `lang` attribute on `<html>`
3. Ensure proper heading hierarchy (h1 → h2 → h3)
4. Add `alt` text to images (empty for decorative)
5. Associate labels with form inputs
6. Provide focus indicators
7. Test with keyboard only (no mouse)
8. Test with screen reader
9. Check color contrast
10. Add loading states with `aria-live`

---

## Resources

- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [React Documentation](https://react.dev)
- [Next.js Documentation](https://nextjs.org/docs)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [MDN Web Accessibility](https://developer.mozilla.org/en-US/docs/Web/Accessibility)
- [WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/)